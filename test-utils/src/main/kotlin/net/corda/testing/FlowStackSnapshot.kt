package net.corda.testing

import co.paralleluniverse.fibers.Fiber
import co.paralleluniverse.fibers.Instrumented
import co.paralleluniverse.fibers.Stack
import co.paralleluniverse.fibers.Suspendable
import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.SerializationFeature
import net.corda.core.flows.FlowLogic
import net.corda.core.internal.FlowStateMachine
import net.corda.core.serialization.SerializeAsToken
import net.corda.node.services.api.ServiceHubInternal
import net.corda.testing.FlowStackSnapshot.Frame
import java.io.File
import java.nio.file.Path
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * Main data object representing snapshot of the flow stack, extracted from the Quasar stack.
 */
data class FlowStackSnapshot constructor(
        val timestamp: Long = System.currentTimeMillis(),
        val flowClass: Class<*>? = null,
        val stackFrames: List<Frame> = listOf()
) {
    data class Frame(
            val stackTraceElement: StackTraceElement? = null, // This should be the call that *pushed* the frame of [objects]
            val stackObjects: List<Any?> = listOf()
    )
}

/**
 * Token class, used to indicate stack presence of the corda internal data. Since this data is of no use for
 * a CordApp developer, it is skipped from serialisation and its presence is only marked by this token.
 */
data class StackFrameDataToken(val className: String)

/**
 * Returns a shallow copy of the Quasar stack frames at the time of call to [flowStackSnapshot]. Use this to inspect
 * what objects would be serialised at the time of call to a suspending action (e.g. send/receive).
 */
@Suspendable
fun FlowLogic<*>.flowStackSnapshot(): FlowStackSnapshot = stateMachine.flowStackSnapshot(this::class.java)

/**
 * Persists a shallow copy of the Quasar stack frames at the time of call to [persistFlowStackSnapshot].
 * Use this to track the monitor evolution of the quasar stack values during the flow execution.
 * The flow stack snapshot is stored in a file located in {baseDir}/flowStackSnapshots/YYYY-MM-DD/{flowId}/
 * where baseDir is the node running directory and flowId is the flow unique identifier generated by the platform.
 *
 * Note: With respect to the [flowStackSnapshot], the snapshot being persisted by this method is partial,
 * meaning that only flow relevant traces and local variables are persisted.
 */
@Suspendable
fun FlowLogic<*>.persistFlowStackSnapshot(): Unit = stateMachine.persistFlowStackSnapshot(this::class.java)

@Suspendable
private fun FlowStateMachine<*>.flowStackSnapshot(flowClass: Class<*>): FlowStackSnapshot {
    var snapshot: FlowStackSnapshot? = null
    val stackTrace = Fiber.currentFiber().stackTrace
    Fiber.parkAndSerialize { fiber, _ ->
        snapshot = extractStackSnapshotFromFiber(fiber, stackTrace.toList(), flowClass)
        Fiber.unparkDeserialized(fiber, fiber.scheduler)
    }
    // This is because the dump itself is on the stack, which means it creates a loop in the object graph, we set
    // it to null to break the loop
    val temporarySnapshot = snapshot
    snapshot = null
    return temporarySnapshot!!
}

private class ThreadLocalIndex private constructor() {

    companion object {
        val currentIndex = object: ThreadLocal<Int>() {
            override fun initialValue(): Int {
                return 0
            }
        }
    }
}

@Suspendable
private fun FlowStateMachine<*>.persistFlowStackSnapshot(flowClass: Class<*>): Unit {
    val flowStackSnapshot = this.flowStackSnapshot(flowClass)
    val mapper = ObjectMapper()
    mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
    mapper.enable(SerializationFeature.INDENT_OUTPUT)
    mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
    val file = createFile((serviceHub as ServiceHubInternal).configuration.baseDirectory, this.id.toString())
    file.bufferedWriter().use { out ->
        mapper.writeValue(out, filterOutStackDump(flowStackSnapshot))
    }
}

private fun extractStackSnapshotFromFiber(fiber: Fiber<*>, stackTrace: List<StackTraceElement>, flowClass: Class<*>): FlowStackSnapshot {
    val stack = getFiberStack(fiber)
    val objectStack = getObjectStack(stack).toList()
    val frameOffsets = getFrameOffsets(stack)
    val frameObjects = frameOffsets.map { (frameOffset, frameSize) ->
        objectStack.subList(frameOffset + 1, frameOffset + frameSize + 1)
    }
    // We drop the first element as it is corda internal call irrelevant from the perspective of a CordApp developer
    val relevantStackTrace = removeConstructorStackTraceElements(stackTrace).drop(1)
    val stackTraceToAnnotation = relevantStackTrace.map {
        val element = StackTraceElement(it.className, it.methodName, it.fileName, it.lineNumber)
        element to getInstrumentedAnnotation(element)
    }

    val frameObjectsIterator = frameObjects.listIterator()
    val frames = stackTraceToAnnotation.reversed().map { (element, annotation) ->
        // If annotation is null then the case indicates that this is an entry point - i.e.
        // the net.corda.node.services.statemachine.FlowStateMachineImpl.run method
        if (frameObjectsIterator.hasNext() && (annotation == null || !annotation.methodOptimized)) {
            Frame(element, frameObjectsIterator.next())
        } else {
            Frame(element, listOf())
        }
    }
    return FlowStackSnapshot(flowClass = flowClass, stackFrames = frames)
}

private fun getInstrumentedAnnotation(element: StackTraceElement): Instrumented? {
    for (method in Class.forName(element.className).methods) {
        if (method.name == element.methodName && method.isAnnotationPresent(Instrumented::class.java)) {
            return method.getAnnotation(Instrumented::class.java)
        }
    }
    return null
}

private fun removeConstructorStackTraceElements(stackTrace: List<StackTraceElement>): List<StackTraceElement> {
    val newStackTrace = ArrayList<StackTraceElement>()
    var previousElement: StackTraceElement? = null
    for (element in stackTrace) {
        if (element.methodName == previousElement?.methodName &&
                element.className == previousElement?.className &&
                element.fileName == previousElement?.fileName) {
            continue
        }
        newStackTrace.add(element)
        previousElement = element
    }
    return newStackTrace
}

private fun filterOutStackDump(flowStackSnapshot: FlowStackSnapshot): FlowStackSnapshot {
    val framesFilteredByStackTraceElement = flowStackSnapshot.stackFrames.filter {
        !FlowStateMachine::class.java.isAssignableFrom(Class.forName(it.stackTraceElement!!.className))
    }
    val framesFilteredByObjects = framesFilteredByStackTraceElement.map {
        Frame(it.stackTraceElement, it.stackObjects.map {
            if (it != null && (it is FlowLogic<*> || it is FlowStateMachine<*> || it is Fiber<*> || it is SerializeAsToken)) {
                StackFrameDataToken(it::class.java.name)
            } else {
                it
            }
        })
    }
    return FlowStackSnapshot(flowStackSnapshot.timestamp, flowStackSnapshot.flowClass, framesFilteredByObjects)
}

private fun createFile(baseDir: Path, flowId: String): File {
    var file: File
    val dir = File(baseDir.toFile(), "flowStackSnapshots/${LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE)}/$flowId/")
    val index = ThreadLocalIndex.currentIndex.get()
    if (index == 0) {
        dir.mkdirs()
        file = File(dir, "flowStackSnapshot.json")
    } else {
        file = File(dir, "flowStackSnapshot-${index}.json")
    }
    ThreadLocalIndex.currentIndex.set(index+1)
    return file
}

private inline fun <reified R, A> R.getField(name: String): A {
    val field = R::class.java.getDeclaredField(name)
    field.isAccessible = true
    @Suppress("UNCHECKED_CAST")
    return field.get(this) as A
}

private fun getFiberStack(fiber: Fiber<*>): Stack {
    return fiber.getField("stack")
}

private fun getObjectStack(stack: Stack): Array<Any?> {
    return stack.getField("dataObject")
}

private fun getPrimitiveStack(stack: Stack): LongArray {
    return stack.getField("dataLong")
}

/*
 * Returns pairs of (offset, size of frame)
 */
private fun getFrameOffsets(stack: Stack): List<Pair<Int, Int>> {
    val primitiveStack = getPrimitiveStack(stack)
    val offsets = ArrayList<Pair<Int, Int>>()
    var offset = 0
    while (true) {
        val record = primitiveStack[offset]
        val slots = getNumSlots(record)
        if (slots > 0) {
            offsets.add(offset to slots)
            offset += slots + 1
        } else {
            break
        }
    }
    return offsets
}

private val MASK_FULL: Long = -1L

private fun getNumSlots(record: Long): Int {
    return getUnsignedBits(record, 14, 16).toInt()
}

private fun getUnsignedBits(word: Long, offset: Int, length: Int): Long {
    val a = 64 - length
    val b = a - offset
    return word.ushr(b) and MASK_FULL.ushr(a)
}
